#!/usr/bin/env ruby
#
# == Synopsis 
#   A ruby backup front-end powered by rsync that can save
#   multiple backup profiles between uses in an sqlite database
#
# == Usage 
#   rubac [options]
#
#   For help use: rubac -h
#
# == Options
#   -g, --global          Apply includes, excludes, options etc., to global profile
#   -p, --profile=NAME    Name of backup profile (default is rubac)
#   -D, --datadir=PATH   Configuration directory (if root /etc/rubac otherwise ~/.rubac)
#
#   -c, --client=HOST     Client to backup (default is localhost)
#   -i, --include=PATH    Include path, comma separate multiple paths
#   -x, --exclude=PATH    Exclude path, comma separate multiple paths
#   -o, --opts=OPTS       Extra rsync options
#   -E, --delete=PATH     Delete any specified includes, excludes or opts
#   -d, --dest=DEST       Local destination path (eg., /mnt/backup)
#   -m, --mail=EMAIL      Notification email, comma separated list
#   -S, --smtp=SERVER     IP Address of smtp server (default is localhost)
#
#   -L, --logdir=PATH     Directory for logging (root default is /var/log/rubac, otherwise ENV['TMP'])
#   -l, --log[=NAME]      Name of log file, (default is %profile%.%run_date%.log)
#   -y, --syslog          Use syslog for logging [??]
#
#   -t, --list            List the includes, excludes, etc., for the named profile
#   -F, --full            Perform full backup, no incremental backups
#   -I, --incremental[=N] Number of incremental backups (default is 5)
#   -r, --run             Run specified profile
#   -s, --snapshot=NAME   Created a snapshot based on most recent backup
#   -n, --dry-run         Perform a trial run of the backup
#
#   -H, --history         Backup history
#   -h, --help            Displays help message
#   -v, --version         Display the version
#   -q, --quiet           Output as little as possible, overrides verbose
#   -V, --verbose         Verbose output
#
# == Examples
#
#   Setup and use a default backup
#
#   rubac -g -o "--delete-excluded"
#   rubac -g --datadir=/etc/rubac
#   rubac -i "/home/steeve,/home/lissa,/home/etienne" -x "*/.gvfs/"
#   rubac -x "*/.thumbnails/,*/.thunderbird/*/ImapMail/,*/.beagle/"
#   rubac -m backupadmin@mail.host
#   rubac -l /var/log/rubac
#   ...
#   rubac --run
#
#   List then backup client esme using the esme profile
#   rubac -c esme -p esme --list
#   rubac -c esme -p esme --run
#
#   Should one be able to specify a client using rsync notation,
#
#   rubac -c donkey -i "/home/steeve,/home/lissa,/home/etienne" -x "*/.gvfs/"
#   rubac -i "donkey:/home/steeve,donkey:/home/lissa,donkey:/home/etienne"
#
#   Each include path should probably include a client (unless local) so
#   the host should be part of the includes database table.
#
# == Environment Variables ==
#
#   RUBAC_DATADIR - set the database directory
#   RUBAC_PROFILE - set the backup profile to use
#   RUBAC_CLIENT  - set the client to use
#   RUBAC_SSHOPTS - set the ssh opts (defaults to -a)
#   RUBAC_RSYNC   - set the rsync command path
#   RSYNC_RSH     - ssh command string, defaults to "ssh" here
#
# == Author
#   Steeve McCauley
#
# == Copyright
#   Copyright (c) 2009 Steeve McCauley. Licensed under the GPL
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# $Id$

require 'optparse' 
require 'rdoc/usage'
require 'net/smtp'
require 'ostruct'
require 'date'
require 'socket'
require 'tmpdir'

require 'xmlsimple'

require 'net/smtp'
require 'rbconfig'	# ruby config

class Email
	def address_email(addr, name="")
		eaddr = { :name => name, :addr => addr }
		eaddr.to_hash
	end

	def send_email(from, to, subject, body, server='localhost')
		msg = <<END_OF_MESSAGE
From: #{from[:name]} <#{from[:addr]}>
To: #{to[:name]} <#{to[:addr]}>
Subject: #{subject}
 
#{body}
END_OF_MESSAGE
 
		Net::SMTP.start(server) do |smtp|
			smtp.send_message msg, from[:addr], to[:addr]
		end
	end
end

module SzMsg
	@console = true
	@syslog = false
	@privlog = true
	@notify = false
	@loglevels = {	"emerg"  => 0,
			"alert"  => 1,
			"crit"   => 2,
			"err"    => 3,
			"warn"   => 4,
			"notice" => 5,
			"info"   => 6,
			"debug"  => 7 }
	# default log level
	@loglevel = @loglevels["info"]

	def level(lvl)
		if @loglevels[lvl].has_key?
			@loglevel = @loglevels[lvl]
		else
			@loglevel = @loglevels["info"]
			err "Unknown log level"
		end
	end

	def message(msg, level)
		# console
		# syslog
		# private log
		# notification
		return if @loglevels[level] > @loglevel
		print "#{msg}\n" if @console
		notify_buffer << msg if @notify
	end

	def printf(fmt, msg)
		sprintf(msg, fmt, msg)
		message(msg, "info")
	end

	def info(msg)
		message(msg, "info")
	end

	def warning(msg)
		msg = "Warning: #{msg}"
		message(msg, "warn")
	end

	def err(msg)
		msg = "Error: #{msg}"
		message(msg, "err")
	end

	def debug(msg)
		msg = "Debug: #{msg}"
		message(msg, "debug")
	end

	def alert(msg)
		msg = "Alert: #{msg}"
		message(msg, "alert")
	end

	def die(msg, e=1)
		alert(msg)
		exit e
	end
end
 
#require 'rubac_db'
#require 'szmsg'

#
# rsync version must be at least 2.5.6 for --link-dest option
#

class Config_rubac
	#
	# configuration template hash
	#
	def initialize
		@def_config = {
			'globals' => {
				'version' => {
					'major' => '0',
					'minor' => '8',
					'revision' => "$Rev$"[6..-3]
				},
				'opts' => '',
				'includes' => '',
				'excludes' => '',
				'dest' => '',
				'ninc' => '5',
				'logdir' => '',
				'logname' => '',
				'email' => '',
				'smtp' => 'localhost'
			},
			'clients' => {
				'localhost' => {
					'host' => '',
					'includes' => '',
					'excludes' => '',
					'opts' => '',
					'ninc' => '5',
					'incrementals' => { '0' => "" }
				}
			}
		}
		@config = {}
	end

	def version
		@config['globals']['version']['major'] + "." +
		@config['globals']['version']['minor'] + " " +
		"(rev #{@config['globals']['version']['revision']})"
	end

	# set config file version to match script version, do any version
	# checking here as well for compatibility reasons, if any
	def align_version
		ver = Hash.new
		ver = @def_config['globals']['version']
		# compare ver and @config['globals']['version'] here
		@config['globals']['version'] = ver
	end

	# load the xml config
	def load_xml(file, path="./")
		@xml_file = File.join(path, file)
		if File.exist?(@xml_file)
			@config = XmlSimple.xml_in(@xml_file, 'ForceArray' => false)
		else
			puts "Config #{@xml_file} not found, using default"
			@config = @def_config.to_hash
		end
		puts "##### load_xml #{@xml_file}" if @debug
		puts "YAML.dump=" + YAML.dump(@config) + "\n"

		align_version
	end

	# save the xml config
	def save_xml
		out = XmlSimple.xml_out(@config, { 'RootName' => 'rubac_config', 'NoAttr' => true, 'AttrPrefix' => true } )
		xml="<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n" + out

		file = File.new(@xml_file, "w")
		file << xml
		file.close

		xml
	end

	def add_client(host)
		return if @config['clients'].has_key?(host)
		client = Hash.new
		client["#{host}"] = @def_config['clients']['localhost']
		@config['clients'].merge!(client)
	end

	def add_client_key(host, key)
		add_client(host)
		@config['clients']["#{host}"]["#{key}"] = @def_config['clients']['localhost']["#{key}"]
	end

	def get_config
		@config.to_hash
	end

	def get_global_config
		@config['globals'].to_hash
	end

	def append_global_key(item, key)
		# key can be a comma separated list, should convert to array
		# and compare all values of the with all values in keys below
		keys = key.split(",")
		keys.each { |k| k.strip! }
		
		items = []
		if @config['globals']["#{item}"].split(",").length > 0
			items=@config['globals']["#{item}"].split(",")
		end
		# merge, removing duplicates
		items = items | keys
		@config['globals']["#{item}"] = items.join(",")
	end

	# add the specified includes to the global include list
	def append_global_includes(inc)
		append_global_key("includes", inc)
	end

	# add the specified excludes to the global exclude list
	def append_global_excludes(exc)
		append_global_key("excludes", exc)
	end

	# add the specified opts to the global opts list
	def append_global_opts(opts)
		append_global_key("opts", opts)
	end

	def get_global_key_value(key, default = "")
		if not @config['globals'].has_key?("#{key}")
			@config['globals']["#{key}"] = default
		end
		@config['globals']["#{key}"]
	end

	def get_global_ninc(ninc)
		if not @config['globals'].has_key?('ninc')
			@config['globals'] << { 'ninc' => 5 }
		end
		@config['globals']['ninc']
	end

	def set_global_ninc(ninc)
		if not @config['globals'].has_key?('ninc')
			@config['globals'] << { 'ninc' => 5 }
		end
		@config['globals']['ninc'] = ninc
	end

	# set the specified path to the global backup destination
	def set_global_dest(dest)
		@config['globals']['dest'] = dest
	end

	def get_global_dest
		@config['globals']['dest'].to_s
	end

	def get_client_config(host)
		add_client(host) if not @config['clients'].has_key?(host)
		@config['clients']["#{host}"]
	end

	# overwrite includes for specified client
	def set_client_includes(host, inc)
		get_client_config(host)
		@config['clients']["#{host}"]['includes'] = inc
	end

	# overwrite excludes for specified client
	def set_client_excludes(host, exc)
		get_client_config(host)
		@config['clients']["#{host}"]['excludes'] = exc 
	end

	# overwrite opts for specified client
	def set_client_opts(host, opts)
		get_client_config(host)
		@config['clients']["#{host}"]['opts'] = opts
	end

	# overwrite number of incrementals value for specified host
	def set_client_ninc(host, ninc)
		get_client_config(host)
		@config['clients']["#{host}"]['ninc'] = ninc
	end

	# set the value of the incremental string (eg. rubac.2009-12-31_10:10:07.3)
	def set_client_incremental(host, n, name)
		get_client_config(host)
		@config['clients']["#{host}"]['incrementals']["#{n}"] = name
		puts "set incr[#{n}]=#{name}"
	end

	def get_client_incrementals(host, n)
		get_client_config(host)
		if not @config['clients']["#{host}"].has_key?('incrementals')
			puts "DEBUG: incrementals not found for host=#{host}"
			@config['clients']["#{host}"]['incrementals'] = { "#{n}" => "" }
		end
		if not @config['clients']["#{host}"]['incrementals'].has_key?("#{n}")
			@config['clients']["#{host}"]['incrementals']["#{n}"] = ""
		end
		puts "GET: incr[#{n}]=" + @config['clients']["#{host}"]['incrementals']["#{n}"].to_s
		@config['clients']["#{host}"]['incrementals']["#{n}"].to_s
	end

	# append (or set) the specified item for the specified client
	def append_client_key(host, item, key)
		get_client_config(host)
		# key can be a comma separated list, should convert to array
		# and compare all values of the with all values in keys below
		keys = key.split(",")
		keys.each { |k| k.strip! }

		items = []
		if @config['clients']["#{host}"]["#{item}"].length > 0
			items = @config['clients']["#{host}"]["#{item}"].split(",")
		end
		items = items | keys
		@config['clients']["#{host}"]["#{item}"] = items.join(",")
	end

	# append (or set) includes for specified client
	def append_client_includes(host, inc)
		append_client_key(host, "includes", inc)
	end

	# append (or set) excludes for specified client
	def append_client_excludes(host, exc)
		append_client_key(host, "excludes", exc)
	end

	# append (or set) opts for specified client
	def append_client_opts(host, opts)
		append_client_key(host, "opts", opts)
	end

	def get_clients
		@config['clients'].to_hash
	end

	# get the specified key value from globals and clients
	# and return a comma delimited list
	def get_client_key(host, key, delim=",")
		get_client_config(host)

		if delim == nil
			return @config['clients']["#{host}"]["#{key}"]
		end

		inc = []
		if @config['globals']["#{key}"].length > 0
			inc = @config['globals']["#{key}"].split(",")
		end

		if @config['clients']["#{host}"]["#{key}"].length > 0
			# eliminate duplicates, if any
			inc = inc | @config['clients']["#{host}"]["#{key}"].split(delim)
		end

		if host != "localhost" and key == "includes"
			inc.each_index do |i|
				inc[i] = "#{host}:" + inc[i]
			end
		end

		inc.join(delim)
	end

	def get_client_includes(host)
		get_client_key(host, 'includes')

	end

	def get_client_excludes(host)
		get_client_key(host, 'excludes')
	end

	def get_client_opts(host)
		get_client_key(host, 'opts', " ")
	end

	def get_client_ninc(host)
		get_client_key(host, 'ninc', nil)
	end
end

class Rubac
	#include Szmsg

	attr_reader :options

	def initialize(arguments, stdin)

		if ENV['RUBAC_RSYNC']
			@rsync=ENV['RUBAC_RSYNC']
		else
			@rsync="rsync"
		end

		@includes = ""
		@excludes = ""
		@useropts = ""
		# rsync -a --relative --delete --delete-excluded --link-dest=/home/rubac/linguini/default/rubac.1 /home/etienne /home/rubac/linguini/default/rubac.0
		if ENV['RUBAC_SSHOPTS']
			@sshopts = ENV['RUBAC_SSHOPTS']
		else
			@sshopts = "-a"
		end
		@sshopts << " --relative --delete --delete-excluded --ignore-errors"

		# use the value set in the environment, if set
		if ENV['RSYNC_RSH']
			@rsync_rsh = nil
		else
			@rsync_rsh = "-e ssh"
		end

		@arguments = arguments
		@stdin = stdin
		@revision = "$Rev$"[6..-3]
			      
		# Set defaults
		@options = OpenStruct.new
		@options.global = false
		@options.dbname = nil
		@options.ninc = 5	# means 5 incrementals, 1-5 with main backup 0
		
		if ENV['RUBAC_PROFILE'] and ENV['RUBAC_PROFILE'].length > 0
			@options.profile = ENV['RUBAC_PROFILE']
		else
			@options.profile = "rubac"
		end

		# hn = Socket.gethostname
		# "lingini.home"
		# hna = Socket.gethostbyname(hn)
		# ["linguini.home", [], 2, "\300\250\001o"]
		#begin
		#	@options.client = Socket.gethostname
		#rescue
		#	@options.client = "localhost"
		#end
		if ENV['RUBAC_CLIENT'] and ENV['RUBAC_CLIENT'].length > 0
			@options.client = ENV['RUBAC_CLIENT']
		else
			@options.client = "localhost"
		end

		# 
		# If /etc/rubac is writable use it as default, otherwise use
		# ~/.rubac/ (does this work for windoze?)
		#
		if ENV['RUBAC_DATADIR']
			@options.datadir = ENV['RUBAC_DATADIR']
		else
			system_dir = "/etc/rubac"
			use_local = true
			begin
				Dir.mkdir(system_dir)
				use_local = false
			rescue Errno::EACCES
				use_local = true
			rescue Errno::EEXIST
				use_local = false
			end

			if use_local == false and File.writable?(system_dir)
				@options.datadir = system_dir
			else
				@options.datadir = File.expand_path("~") + "/.rubac"
			end
			ENV['RUBAC_DATADIR'] = @options.datadir
		end

		begin
			FileUtils.mkdir(@options.datadir) if not File.exist?(@options.datadir)
		rescue
			puts "Failed to create data directory #{@options.datadir}"
			exit false
		end

		@options.verbose = false
		@options.quiet = false
		@options.include = nil
		@options.exclude = nil
		@options.dest = nil
		@options.opts = nil
		@options.snapshot = nil
		@options.run = false
		@options.full = false
		@options.cmd = nil
		@options.dry_run = false
		@options.email = nil

		@options.tmp = ENV['TMP'].to_s
		if @options.tmp.length > 0
			@options.tmp = ENV['TMP']
		else
			@options.tmp = Dir.tmpdir
		end

		if Process.uid == 0
			@options.logdir = "/var/log/rubac"
		else
			@options.logdir = "#{@options.tmp}/rubac"
		end

		#
		# TODO - add additional defaults end
		#
	end

	# ensure that rsync is at least 2.5.6
	def rsync_check_version
		# rsync version must be at least 2.5.6 for --link-dest option
		rsync_version = `#{@rsync} --version`
		if $?.exitstatus != 0
			puts "Error: running #{@rsync} --version"
			exit(1)
		end
		rsync_version = rsync_version[/^rsync\s+version\W+\d+\.\d+\.\d+/]
		if rsync_version == nil
			puts "Error: could not determine rsync version"
			exit(1)
		end
		rsync_version = rsync_version[/\d+\.\d+\.\d/]
		rva = rsync_version.split(/\./)
		rvi = rva[0].to_i * 100 + rva[1].to_i * 10 + rva[2].to_i
		if rvi < 256
			puts "rsync version is too old, require at least rsync version 2.5.6"
			exit(1)
		end
	end

	# Parse options, check arguments, then process the command
	def main
 
		rsync_check_version

		if arguments_valid? && parsed_options?

			puts "Start at #{DateTime.now}\n\n" if @options.verbose

			output_options if @options.verbose # [Optional]

			process_arguments            
			process_command

			#puts "\nFinished at #{DateTime.now}" if @options.verbose
		else
			usage_command
		end
	end

	protected

	def set_command(c)
		if @options.cmd == nil
			@options.cmd="#{c}_command"
		else
			warn "Command is already set to #{@options.cmd}, ignoring #{c} command"
		end
	end

	def parsed_options?

		# Specify options
		opts = OptionParser.new 
		opts.on('-V', '--verbose', "Run verbosely")    { @options.verbose = true }  
		opts.on('-q', '--quiet',   "Run quietly")      { @options.quiet = true }

		opts.on('-g', '--global', "Apply options to the global profile") { @options.global = true }

		opts.on('-LPATH', '--logdir PATH', "Set the log directory") do |dir|
			if not File.exist?(dir)
				begin
					FileUtils.mkdir(dir)
				rescue Errno::EACCES
					puts "Error: permission denied creating log dir #{dir}"
					exit 1
				rescue
					puts "Error: creating log dir #{dir}"
					exit 1
				end
			end
			if File.stat(dir).directory?
				@options.logdir = dir
			else
				puts "Error: #{dir} is not a directory"
				exit 1
			end
		end

		opts.on('-cHOST', '--client HOST', "Backup Client hostname") do |host|
			host.strip!
			@options.client = host
		end

		opts.on('-DPATH', '--datadir PATH', "Database directory") do |dir|
			dir.strip!
			@options.datadir = dir
		end

		opts.on('-iPATH', '--include PATH', "Add include path") do |inc|
			# strip whitespace
			inc.strip!
			# remove trailing pathslash, if any
			inc = File.join(File.dirname(inc), File.basename(inc))
			if @options.include
				@options.include = @options.include + ",#{inc}"
			else
				@options.include = inc
			end
		end

		opts.on('-xPATH', '--exclude PATH', "Add exclude path") do |exc|
			exc.strip!
			if @options.exclude
				@options.exclude = @options.exclude + ",#{exc}"
			else
				@options.exclude = exc
			end
		end

		opts.on('-dPATH', '--dest PATH', "Set backup destination") do |dest|
			dest.strip!
			@options.dest = dest
		end

		opts.on('-mLIST', '--mail LIST', "Email notification list") do |email|
			@options.email = email
		end

		opts.on('-F', '--full', "Perform a full backup ignoring incrementals") {
			@options.full = true
			set_command("run")
		}

		opts.on('-IN', '--incremental N', "Set the number of incremental backups") do |ninc|
			ninc = ninc.to_i
			if ninc < 0
				puts "Error: number of incrementals must be greater than or equal to 0"
				puts "       ignoring #{ninc}"
			else
				@options.ninc = ninc
			end
		end

		opts.on('-pNAME', '--profile NAME', "Apply opts to specified profile") do |profile|
			@options.profile = profile
		end
		# TO DO - add additional options

		opts.on('-n', '--dry-run', "Perform a trial run of the backup") do
			@options.dry_run = true
		end

		opts.on('-h', '--help',    "Print help") do   #   { output_help }
			set_command("help")
		end

		opts.on('-r', '--run', "Run the backup") do
			set_command("run")
		end

		opts.on('-sNAME', '--snapshot NAME', "Perform a snapshot backup") do |name|
			@options.snapshot = File.basename(name)
			set_command("snapshot")
		end

		opts.on('-t', '--list', "List the backup options") do
			set_command("list")
		end

		opts.on('-H', '--history', "Backup history") do
			set_command("history")
		end

		opts.on('-v', '--version', "Print version") do
			set_command("version")
		end

		opts.parse!(@arguments) rescue return false

		process_options
		true      
	end

	# Performs post-parse processing on options
	def process_options
		@options.verbose = false if @options.quiet
		@options.dbname = @options.profile + ".xml"
	end

	def output_options
		puts "Options:\n"
      
		@options.marshal_dump.each do |name, val|        
			puts "  #{name} = #{val}"
		end
	end

	# True if required arguments were provided
	def arguments_valid?
		# TO DO - implement your real logic here
		#puts "arguments =  #{@arguments.length} \n"
		true if @arguments.length >= 1 
	end

	# Setup the arguments
	def process_arguments
		# TO DO - place in local vars, etc
		@config = Config_rubac.new
		@config.load_xml(@options.dbname, @options.datadir)

		@config.set_global_dest(@options.dest) if @options.dest
		@options.dest = @config.get_global_dest

		if @options.global
			@config.append_global_includes(@options.include) if @options.include
			@config.append_global_excludes(@options.exclude) if @options.exclude
			@config.append_global_opts(@options.opts) if @options.opts
			@config.set_global_ninc(@options.ninc) if @options.ninc
		else
			if @options.include
				@config.append_client_includes(@options.client, @options.include)
			end
			if @options.exclude
				@config.append_client_excludes(@options.client, @options.exclude)
			end
			if @options.opts
				@config.append_client_opts(@options.client, @options.opts)
			end
			if @options.ninc
				@config.set_client_ninc(@options.client, @options.ninc)
			end
		end

		@xml = @config.save_xml

		@includes = @config.get_client_includes(@options.client)
		@excludes = @config.get_client_excludes(@options.client)
		@useropts = @config.get_client_opts(@options.client)
		@sshopts  << " --dry-run" if @options.dry_run
		@sshopts  << " --verbose" #if @options.verbose

		if not File.exist?(@options.dest)
			puts "Warning: backup destination not set"
		end
	end
    
	def help_command 
		version_command
		# RDoc::usage doesn't work in 1.9.x
		RDoc::usage('Synopsis', 'Usage', 'Options') #exits app
	end
    
	def usage_command
		RDoc::usage('Synopsis', 'Usage', 'Options') # gets usage from comments above
	end
 
	def run_command_prep_linkdest(host, pdest)
		ninc = @config.get_client_ninc(host)

		# setup flags for delete
		rm_flags = { :force => true, :verbose => true }
		if @options.dry_run 
			rm_flags.merge!( :noop => true )
		end

		link_dest = false
		i = []
		i = (1..ninc).to_a.reverse
		i.each do |m|
			n = m - 1
			# Example,
			#   n==4, ndest is rubac.4
			#   m==5, mdest is rubac.5

			nname = @config.get_client_incrementals(host, n)
			mname = @config.get_client_incrementals(host, m)

			puts "n=#{n} nname=#{nname} m=#{m} mname=#{mname}"

			next if nname.length == 0

			ndest = File.join(pdest, nname)
			mdest = File.join(pdest, mname)

			p ndest
			p mdest

			# Someone has deleted an incremental backup
			if not File.exist?(ndest)
				#@config.set_client_incremental(host, m, nname)
				puts "Error: incremental backup #{nname} not found"
				@config.set_client_incremental(host, m, "")
				@config.set_client_incremental(host, n, "")
				next
			end

			if m == ninc and mname.length > 0
				if File.exist?(mdest)
					FileUtils.rm_r(mdest, rm_flags)
				end
			end
			if File.exist?(ndest)
				@config.set_client_incremental(host, m, nname)
				link_dest = true
			end
		end


	end

	def run_command_rsync(host, inc, bdest, ldest)

		logf = File.join(bdest, "rubac.log.yaml")
		if File.exist?(logf)
			log = File.open(logf) { |yf| YAML::load(yf) }
		else
			log = Array.new
		end

		cmd =  %Q(rsync #{@sshopts} #{@useropts})
		cmd << %Q( --link-dest=#{ldest}) if ldest
		# write the excludes to a file and use --exclude-from 
		if @excludes.length > 0
			excl = File.join(@options.tmp, File.basename(bdest) + ".excl")
			exclf = File.open( excl, "w" )
			@excludes.split(",").each do |x|
				exclf.puts(x)
			end
			cmd << %Q( --exclude-from="#{excl}") if @excludes.length > 0
		end
		cmd << %Q( #{inc} #{bdest})
		puts %Q(#{cmd})
		p = IO.popen(%Q(#{cmd}))
		while (line = p.gets)
			line.chop!
			if line[/^#{inc}.*/]
				log << line
			else
				puts line
			end
		end
		## TODO get status of command??
		status=$?
		p status
		#out = %x{#{cmd}}
		#status = $?.exitstatus
		#puts out
		if status and status != 0
			puts "Error: running command %Q(#{cmd})"
			exit(status)
		end

		# remove duplicates
		log.uniq!

		puts "Backup log length=#{log.nitems} to #{logf}"
		File.open( logf, "w" ) do |out|
			YAML.dump( log, out )
		end

		log.each do |entry|
			puts entry
		end
	end

	def get_backup_dirname
		t = Time.now
		t.strftime("%Y-%m-%d_%H-%M-%S")
		"rubac." + t.strftime("%Y-%m-%d_%H-%M-%S")
	end

	# backup to bdir with hardlink to ldir, if it exists
	def run_command
		host = @options.client

		if @options.dest.length == 0
			puts "Error: backup destination not set"
			exit(1)
		end

		if @options.snapshot
			bdir = "rubac.#{@options.snapshot}"
			ldir = @config.get_client_incrementals(host, 0)
		elsif @options.full
			bdir = @config.get_client_incrementals(host, 0)
			bdir = get_backup_dirname if bdir.length == 0
			ldir = "__none__"
		else
			bdir = get_backup_dirname
			ldir = @config.get_client_incrementals(host, 0)
		end

		ldir = "__none__" if ldir.length == 0

		pdest = File.join(@options.dest, @options.profile, host)
		FileUtils.mkdir_p(pdest)

		# if flock(LOCK_EX|LOCK_NB) == false puts "cannot get exclusive lock"
		# g=File.new("/tmp/junkol", File::CREAT|File::RDONLY, 0600)
		# g.flock(File::LOCK_EX|File::LOCK_NB)
		#
		rlock = File.join(pdest, "rubac.runlock")
		runlock = File.new(rlock, File::CREAT|File::RDONLY, 0644)
		if runlock.flock(File::LOCK_EX|File::LOCK_NB) == false
			puts "Error: cannot lock file #{rlock}"
			runlock.close
			return
		end

		bdest = File.join(pdest, bdir)
		ldest = File.join(pdest, ldir)

		if @options.snapshot
			if not File.exist?(ldest)
				puts "Error: run one backup before doing a snapshot"
				exit (1)
			end
		elsif @options.full
			puts "Running full backup on #{bdest}"
			ldest = nil
		else
			# move out incrementals
			run_command_prep_linkdest(host, pdest) if ldir != "__none__"
			# if the link destination doesn't exist, set it to nil
			ldest = nil if not File.exist?(ldest)
		end

		# assert that bdest doesn't exist here?
		FileUtils.mkdir_p(bdest)

		# log history files by include
		# include => "file, file, file, ..."
		inc = @includes.split(",")
		inc.each do |include|
			# strip off any trailing path slashes
			include = File.join(File.dirname(include), File.basename(include))
			run_command_rsync(host, include, bdest, ldest)
			@config.set_client_incremental(host, 0, bdir)
		end

		@config.save_xml

		runlock.flock(File::LOCK_UN)
		File.delete(rlock)
	end

	#
	# Do a backup snapshot (not a real filesystem snapshot) by
	# backing up to the snapshot and linking to rubac.0
	#
	def snapshot_command
		puts "##### Snapshot=#{@options.snapshot} #####"
		run_command
	end

	def list_command_client_key(client, key, delim=",")
		inc = @config.get_client_key(client, key, delim)
		return if inc.length == 0
		inc = inc.split("#{delim}")
		printf "%10s=\n", key
		inc.each do |i|
			printf "\t%-12s\n", i
		end
		puts ""
	end

	def list_command_client(client)
		puts "##### #{client} #####"
		list_command_client_key(client, 'includes')
		list_command_client_key(client, 'excludes')
		list_command_client_key(client, 'opts', " ")
	end

	def list_command

		if @options.verbose
			puts "##### Configuration #####"
			puts "#{@xml}\n"
		end

		puts "##### Global settings #####"
		printf "%10s=%s\n", "profile", @options.profile
		if @options.dest.length == 0
			puts %Q(   *** Warning: backup destination not set)
		else
			printf %Q(%10s=%s\n), "dest", @options.dest
		end
		printf %Q(%10s=%s\n), "ssh opts", @sshopts
		printf %Q(\n)

		if @options.client == "localhost"
			clients = @config.get_clients
			clients.each_key do |cli|
				list_command_client(cli)
			end
		else
			list_command_client(@options.client)
		end

		#to = address_email("steeve.mccauley@gmail.com", "Steeve McCauley")
		#from = address_email("rubac@linguini.home", "Rubac Backup User")
		#subject = "Rubac Test"
		#body = "This is a test email\nThis is the second line\nThis is the last line\n"
		#send_email(from, to, subject, body, "relais.videotron.ca")
	end

	def history_command
		puts "TODO history command"
		# look in /bdest/profile/client/rubac.date,.../rubac.log.yaml
	end

	def version_command
		ver = @config.version
		puts "#{File.basename(__FILE__)} " + ver
	end
    
	def process_command
		if @options.cmd
			version_command
			eval @options.cmd if @options.cmd != "version_command"
		else
			puts "huh? #{Config::CONFIG['host_os']}"
		end

	end

	#def process_standard_input
	#	input = @stdin.read      
		# TO DO - process input

		# [Optional]
		# @stdin.each do |line| 
		#  # TO DO - process each line
		# end
	#end
end

rubac = Rubac.new(ARGV, STDIN)
rubac.main

