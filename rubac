#!/usr/bin/env ruby
#
# == Synopsis 
#   A ruby backup front-end powered by rsync that can save
#   multiple backup profiles between uses.
#
# == Usage 
#   rubac [options]
#
#   For help use: rubac -h
#
# == Options
#   -g, --global            Apply includes, excludes, options etc., to global profile
#   -p, --profile=NAME      Name of backup profile (default is rubac)
#   -D, --datadir=PATH      Configuration directory (if root /etc/rubac otherwise ~/.rubac)
#
#   -c, --client=HOST       Client to backup (default is localhost), can specify multiple clients
#   -a, --address=HOST      Set the client host address (default is the client name)
#   -i, --include=PATH      Include path, comma separate multiple paths
#   -x, --exclude=PATH      Exclude path, comma separate multiple paths
#   -o, --opts=OPTS         Extra rsync options
#       --delete=PATH       Delete any specified includes, excludes or opts
#   -d, --dest=DEST         Local destination path (eg., /mnt/backup)
#   -m, --mail=EMAIL        TODO Notification email, comma separated list
#       --smtp=SERVER       TODO IP Address of smtp server (default is localhost)
#
#   -L, --logdir=PATH       TODO Directory for logging (root default is /var/log/rubac, otherwise TMP)
#       --log[=NAME]        TODO Name of log file, (default is %profile%.%run_date%.log)
#   -y, --syslog            TODO Use syslog for logging [??]
#
#   -l, --list              List the includes, excludes, etc., for the named profile
#   -u, --update            Perform update backup, no incremental backups
#   -I, --incremental[=N]   Number of incremental backups (default is 5)
#   -r, --run               Run specified profile
#   -s, --snapshot=NAME     Created a snapshot based on most recent backup
#   -n, --dry-run           Perform a trial run of the backup
#   -z, --compress          TODO Compress the file data during backup
#
#   -H, --history[=INDEX]   TODO Backup history, or specify index to see backup details
#   -T, --restore-to=PATH   TODO Restore to the given base path (default is TMP)
#   -R, --restore=FILE      TODO Restore file as file[:index] if the incremental index is not given it defaults to most recent
#   -F, --restore-from=FILE TODO Restore file list from the given file (comma or new line delimited)
#   -S, --search=GLOB       TODO Search for the given glob in the backup history
#
#   -h, --help              Displays help message
#   -v, --version           Display the version
#   -q, --quiet             Output as little as possible, overrides verbose
#   -V, --verbose           Verbose output
#
# == Examples
#
#   Setup and use a default backup
#
#   rubac -g -o "--delete-excluded"
#   rubac -g --datadir=/etc/rubac
#   rubac -i "/home/steeve,/home/lissa,/home/etienne" -x "*/.gvfs/"
#   rubac -x "*/.thumbnails/,*/.thunderbird/*/ImapMail/,*/.beagle/"
#   rubac -m backupadmin@mail.host
#   rubac -l /var/log/rubac
#   ...
#   rubac --run
#
#   List then backup client esme using the esme profile
#   rubac -c esme -p esme --list
#   rubac -c esme -p esme --run
#
#   Should one be able to specify a client using rsync notation,
#
#   rubac -c donkey -i "/home/steeve,/home/lissa,/home/etienne" -x "*/.gvfs/"
#   rubac -i "donkey:/home/steeve,donkey:/home/lissa,donkey:/home/etienne"
#
#   Each include path should probably include a client (unless local) so
#   the host should be part of the includes database table.
#
# == Environment Variables ==
#
#   RUBAC_DATADIR - set the database directory
#   RUBAC_PROFILE - set the backup profile to use
#   RUBAC_CLIENT  - set the client to use
#   RUBAC_SSHOPTS - set the ssh opts (defaults to -a)
#   RUBAC_RSYNC   - set the rsync command path
#   RSYNC_RSH     - ssh command string, defaults to "ssh" here
#
# == Author
#   Steeve McCauley
#
# == Copyright
#   Copyright (c) 2009 Steeve McCauley. Licensed under the GPL
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# $Id$

require 'optparse' 
require 'rdoc/usage'
require 'net/smtp'
require 'ostruct'
require 'date'
require 'socket'
require 'tmpdir'
require 'open3'

require 'xmlsimple'

require 'net/smtp'
require 'rbconfig'	# ruby config

#$debug = true

CONFIG_KEY_VER="version"
CONFIG_KEY_VER_MAJ="major"
CONFIG_KEY_VER_MIN="minor"
CONFIG_KEY_VER_REV="revision"

CONFIG_KEY_GLOBALS="globals"
CONFIG_KEY_INC="includes"
CONFIG_KEY_EXC="excludes"
CONFIG_KEY_OPT="opts"
CONFIG_KEY_DEST="dest"
CONFIG_KEY_NINC="ninc"
CONFIG_KEY_LOGDIR="logdir"
CONFIG_KEY_LOGNAME="logname"
CONFIG_KEY_EMAIL="email"
CONFIG_KEY_SMTP="smtp"

UPDATE_CMD_ADD="add"
UPDATE_CMD_DEL="delete"

class Email

	attr_accessor :server

	def initialize(server="localhost")
		@server=server
		@to = []
		@from = {}
		@attach = nil
	end

	def address_email(addr, name=nil)
		return if not addr
		addr.strip!
		name.strip! if name
		eaddr = { :name => name, :addr => addr }
		eaddr.to_hash
	end

	def to(addr, name=nil)
		@to << address_email(addr, name)
	end

	def from(addr, name=nil)
		@from = address_email(addr, name)
	end

	def send(subject, body, server='localhost')
		tstr = ""
		@to.each do |a|
			tstr << "#{a[:name]} " if a[:name]
			tstr << "<#{a[:addr]}>, "
		end
		fstr = ""
		fstr << "#{@from[:name]} " if @from[:name]
		fstr << "<#{@from[:addr]}> "

		sstr = "#{subject}"

		msg = <<END_OF_MESSAGE
From: #{fstr}
To: #{tstr}
Subject: #{sstr}
 
#{body}
END_OF_MESSAGE
 
		@to.each { |a|
		Net::SMTP.start(server) do |smtp|
			smtp.send_message msg, @from[:addr], a[:addr]
		end
		}
	end
end

class Msg
	attr_accessor :console
	attr_accessor :syslog
	attr_accessor :privlog
	attr_accessor :notify
	attr_accessor :loglevels
	attr_accessor :loglevel

	def initialize(dest=nil)
		me=self.class.name

		puts "Init #{me}: #{dest}" if @debug

		@LOGLEVELS = {	"emerg"  => 0,
				"alert"  => 1,
				"crit"   => 2,
				"err"    => 3,
				"warn"   => 4,
				"notice" => 5,
				"info"   => 6,
				"debug"  => 7 }

		@loglevel = @LOGLEVELS["info"]

		@console = true
		@syslog = false
		@privlog = true
		@notify = false

		return if dest == nil

		adest = dest.split(",")
		adest.each do |d|
			d.strip!
			puts "Setting dest=#{d}" if @debug
			case d
			when 'console'
				@console = true
			when 'syslog'
				@syslog = true
			else
				puts "Unknown log destination \"#{d}\" in #{me}"
			end
		end
		# default log level
	end
private
	def MLmessage(msg, lvl)
		# console
		# syslog
		# private log
		# notification
		puts "shit" if not @LOGLEVELS.has_key?(lvl)
		return if @LOGLEVELS[lvl].to_i > @loglevel
		puts msg if @console
		#msg_buffer << msg if @notify
	end
public
	def level(lvl)
		if @LOGLEVELS[lvl].has_key?
			@loglevel = @LOGLEVELS[lvl]
		else
			@loglevel = @LOGLEVELS["info"]
			err "Unknown log level"
		end
	end

	def info(msg)
		MLmessage(msg, "info")
	end

	def warn(msg)
		MLmessage("Warning: " + msg, "warn")
	end

	def err(msg)
		MLmessage("Error: " + msg, "err")
	end

	def debug(msg)
		MLmessage("Debug: " + msg, "debug")
	end

	def alert(msg)
		MLmessage("Alert: " + msg, "alert")
	end

	def die(msg, e=1)
		err(msg)
		exit e
	end
end
 
#
# rsync version must be at least 2.5.6 for --link-dest option
#

class Config_rubac
	#
	# configuration template hash
	#
	def initialize
		@def_config = {
			'globals' => {
				'version' => {
					'major' => '0',
					'minor' => '8',
					'revision' => "$Rev$"[6..-3]
				},
				'opts' => '',
				'includes' => '',
				'excludes' => '',
				'dest' => '',
				'ninc' => '5',
				'logdir' => '',
				'logname' => '',
				'email' => '',
				'smtp' => 'localhost'
			},
			'clients' => {
				'localhost' => {
					'address' => '',
					'includes' => '',
					'excludes' => '',
					'opts' => '',
					'ninc' => '5',
					'incrementals' => { '0' => "" }
				}
			}
		}
		@config = {}
	end

	def version
		@config['globals']['version']['major'] + "." +
		@config['globals']['version']['minor'] + " " +
		"(rev #{@config['globals']['version']['revision']})"
	end

	# set config file version to match script version, do any version
	# checking here as well for compatibility reasons, if any
	def align_version
		ver = Hash.new
		ver = @def_config['globals']['version']
		# compare ver and @config['globals']['version'] here
		@config['globals']['version'] = ver
	end

	# load the xml config
	def load_xml(file, path="./")
		@xml_file = File.join(path, file)
		if File.exist?(@xml_file)
			@config = XmlSimple.xml_in(@xml_file, 'ForceArray' => false)
		else
			puts "Config #{@xml_file} not found, using default"
			@config = @def_config.to_hash
		end
		puts "##### load_xml #{@xml_file}" if @debug
		puts "YAML.dump=" + YAML.dump(@config) + "\n" if $debug

		align_version
	end

	# save the xml config
	def save_xml
		out = XmlSimple.xml_out(@config, { 'RootName' => 'rubac_config', 'NoAttr' => true, 'AttrPrefix' => true } )
		xml="<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n" + out

		file = File.new(@xml_file, "w")
		file << xml
		file.close

		xml
	end

	def add_client(host)
		return if @config['clients'].has_key?(host)
		client = Hash.new
		client["#{host}"] = @def_config['clients']['localhost']
		@config['clients'].merge!(client)
	end

	def get_config
		@config.to_hash
	end

	def get_global_config
		@config['globals'].to_hash
	end

	def del_global_key(item, key, delim=",")
		return if key == nil or key.length == 0

		return if not @config['globals'].has_key?(item)

		items = []
		items = @config['globals']["#{item}"].split(delim)
		return if items.nitems == 0

		keys = key.split(delim)
		keys.each { |k|
			k.strip!
			items.delete(k)
		}
		@config['globals']["#{item}"] = items.join(delim)

	end

	def add_global_key(item, key, delim=",")
		return if key == nil or key.length = 0
		# key can be a comma separated list, should convert to array
		# and compare all values of the with all values in keys below
		keys = key.split(delim)
		keys.each { |k| k.strip! }
		
		items = []
		if @config['globals']["#{item}"].split(delim).length > 0
			items=@config['globals']["#{item}"].split(delim)
		end
		# merge, removing duplicates
		items = items | keys
		@config['globals']["#{item}"] = items.join(delim)
	end

	# type is add/delete
	def global_updates(type, inc, exc, opts)
		if type == UPDATE_CMD_DEL
			del_global_key("includes", inc)
			del_global_key("excludes", exc)
			del_global_key("opts", opts, " ")
		else
			add_global_key("includes", inc)
			add_global_key("excludes", exc)
			add_global_key("opts", opts, " ")
		end
	end

	# add the specified includes to the global include list
	def add_global_includes(inc)
		global_updates(UPDATE_CMD_ADD, "includes", inc, nil, nil)
	end

	# add the specified excludes to the global exclude list
	def add_global_excludes(exc)
		global_updates(UPDATE_CMD_ADD, "excludes", nil, exc, nil)
	end

	# add the specified opts to the global opts list
	def add_global_opts(opts)
		global_updates(UPDATE_CMD_ADD, "excludes", nil, nil, opts)
	end

	def get_global_key_value(key, default = "")
		if not @config['globals'].has_key?("#{key}")
			@config['globals']["#{key}"] = default
		end
		@config['globals']["#{key}"]
	end

	def get_global_ninc(ninc)
		get_global_key_value("ninc", @def_config['globals']['ninc'])
	end

	def set_global_key_value(key, value)
		@config['globals']["#{key}"] = value
	end

	# set the specified path to the global backup destination
	def set_global_dest(dest)
		return if dest == nil or dest.length == 0
		@config['globals']['dest'] = dest
	end

	def get_global_dest
		@config['globals']['dest'].to_s
	end

	def get_client_config(host)
		add_client(host) if not @config['clients'].has_key?(host)
		@config['clients']["#{host}"]
	end

	def set_client_key_value(host, key, value)
		get_client_config(host)
		@config['clients']["#{host}"]["#{key}"] = value
	end

	# set the value of the incremental string (eg. rubac.2009-12-31_10:10:07.3)
	def set_client_incremental(host, n, name)
		get_client_config(host)
		@config['clients']["#{host}"]['incrementals']["#{n}"] = name
		puts "set incr[#{n}]=#{name}"
	end

	def get_client_incrementals(host, n)
		get_client_config(host)
		if not @config['clients']["#{host}"].has_key?('incrementals')
			puts "DEBUG: incrementals not found for host=#{host}"
			@config['clients']["#{host}"]['incrementals'] = { "#{n}" => "" }
		end
		if not @config['clients']["#{host}"]['incrementals'].has_key?("#{n}")
			@config['clients']["#{host}"]['incrementals']["#{n}"] = ""
		end
		@config['clients']["#{host}"]['incrementals']["#{n}"].to_s
	end

	def del_client_key(host, item, key, delim=",")
		return if key == nil or key.length == 0
		get_client_config(host)

		return if not @config['clients']["#{host}"].has_key?(item)

		items = []
		items = @config['clients']["#{host}"]["#{item}"].split(delim)
		return if items.nitems == 0

		keys = key.split(delim)
		keys.each { |k|
			k.strip!
			items.delete(k)
		}
		@config['clients']["#{host}"]["#{item}"] = items.join(delim)
	end

	# append (or set) the specified item for the specified client
	def add_client_key(host, item, key, delim=",")
		return if key == nil or key.length == 0

		get_client_config(host)
		# key can be a comma separated list, should convert to array
		# and compare all values of the with all values in keys below
		keys = key.split(delim)
		keys.each { |k| k.strip! }

		items = []
		if @config['clients']["#{host}"]["#{item}"].length > 0
			items = @config['clients']["#{host}"]["#{item}"].split(delim)
		end
		items = items | keys
		@config['clients']["#{host}"]["#{item}"] = items.join(delim)
	end

	# type is add/delete
	def client_updates(host, type, inc, exc, opts)
		if type == UPDATE_CMD_DEL
			del_client_key(host, "includes", inc)
			del_client_key(host, "excludes", exc)
			del_client_key(host, "opts", opts, " ")
		else
			add_client_key(host, "includes", inc)
			add_client_key(host, "excludes", exc)
			add_client_key(host, "opts", opts, " ")
		end
	end


	# append (or set) includes for specified client
	def add_client_includes(host, inc)
		add_client_key(host, "includes", inc)
	end

	# append (or set) excludes for specified client
	def add_client_excludes(host, exc)
		add_client_key(host, "excludes", exc)
	end

	# append (or set) opts for specified client
	def add_client_opts(host, opts)
		add_client_key(host, "opts", opts, " ")
	end

	def get_clients
		@config['clients'].to_hash
	end

	# get the specified key value from globals and clients
	# and return a comma delimited list
	def get_client_key_list(host, key, delim=",")
		get_client_config(host)

		entries = []
		entries = get_global_key_value(key).to_s.split(delim)

		if @config['clients']["#{host}"].has_key?(key) and @config['clients']["#{host}"]["#{key}"].length > 0
			# eliminate duplicates, if any
			entries = entries | @config['clients']["#{host}"]["#{key}"].split(delim)
		end

		addr = get_client_address(host)
		if addr != "localhost" and key == "includes"
			entries.each_index do |i|
				entries[i] = "#{host}:" + entries[i]
			end
		end

		entries.join(delim)
	end

	def get_client_includes(host)
		get_client_key_list(host, 'includes')

	end

	def get_client_excludes(host)
		get_client_key_list(host, 'excludes')
	end

	def get_client_opts(host)
		get_client_key_list(host, 'opts', " ")
	end

	def get_client_key_value(host, key)
		get_client_config(host)
		if not @config['clients']["#{host}"].has_key?(key)
			@config['clients']["#{host}"]["#{key}"] = @def_config['clients']['localhost']["#{key}"]
		end
		@config['clients']["#{host}"]["#{key}"]
	end

	def get_client_ninc(host)
		# TODO if client ninc is not set use global ninc
		get_client_key_value(host, 'ninc').to_i
	end

	def get_client_address(host)
		addr = get_client_key_value(host, 'address')
		addr = host if addr.length == 0
		addr = "localhost" if addr == "127.0.0.1"
	end
end

class Rubac

	attr_reader :options

	def initialize(arguments, stdin)

		if ENV['RUBAC_RSYNC']
			@rsync=ENV['RUBAC_RSYNC']
		else
			@rsync="rsync"
		end

		@includes = ""
		@excludes = ""
		@useropts = ""
		# rsync -a --relative --delete --delete-excluded --link-dest=/home/rubac/linguini/default/rubac.1 /home/etienne /home/rubac/linguini/default/rubac.0
		if ENV['RUBAC_SSHOPTS']
			@sshopts = ENV['RUBAC_SSHOPTS']
		else
			@sshopts = "-a -v -v"
		end
		@sshopts << " --relative --delete --delete-excluded --ignore-errors"

		# use the value set in the environment, if set
		if ENV['RSYNC_RSH']
			@rsync_rsh = nil
		else
			@rsync_rsh = "-e ssh"
		end

		@arguments = arguments
		@stdin = stdin
		@revision = "$Rev$"[6..-3]
			      
		# Set defaults
		@options = OpenStruct.new
		@options.global = false
		@options.dbname = nil
		@options.ninc = nil	# means 5 incrementals, 1-5 with main backup 0
		
		if ENV['RUBAC_PROFILE'] and ENV['RUBAC_PROFILE'].length > 0
			@options.profile = ENV['RUBAC_PROFILE']
		else
			@options.profile = "rubac"
		end

		# hn = Socket.gethostname
		# "lingini.home"
		# hna = Socket.gethostbyname(hn)
		# ["linguini.home", [], 2, "\300\250\001o"]
		#begin
		#	@options.client = Socket.gethostname
		#rescue
		#	@options.client = "localhost"
		#end
		if ENV['RUBAC_CLIENT'] and ENV['RUBAC_CLIENT'].length > 0
			clients = ENV['RUBAC_CLIENT']
			@options.client = clients.split(",")
		else
			@options.client = [ ]
		end

		# 
		# If /etc/rubac is writable use it as default, otherwise use
		# ~/.rubac/ (does this work for windoze?)
		#
		if ENV['RUBAC_DATADIR']
			@options.datadir = ENV['RUBAC_DATADIR']
		else
			system_dir = "/etc/rubac"
			use_local = true
			begin
				Dir.mkdir(system_dir)
				use_local = false
			rescue Errno::EACCES
				use_local = true
			rescue Errno::EEXIST
				use_local = false
			end

			if use_local == false and File.writable?(system_dir)
				@options.datadir = system_dir
			else
				@options.datadir = File.expand_path("~") + "/.rubac"
			end
			ENV['RUBAC_DATADIR'] = @options.datadir
		end

		begin
			FileUtils.mkdir(@options.datadir) if not File.exist?(@options.datadir)
		rescue
			puts "Failed to create data directory #{@options.datadir}"
			exit false
		end

		@options.verbose = false
		@options.quiet = false
		@options.update_cmd = UPDATE_CMD_ADD
		@options.include = nil
		@options.exclude = nil
		@options.dest = nil
		@options.opts = nil
		@options.snapshot = nil
		@options.run = false
		@options.update = false
		@options.cmd = nil
		@options.dry_run = false
		@options.email = nil
		@options.smtp = nil
		@options.hist_index = nil
		@options.address = nil

		@options.tmp = ENV['TMP'].to_s
		if @options.tmp.length > 0
			@options.tmp = ENV['TMP']
		else
			@options.tmp = Dir.tmpdir
		end

		if Process.uid == 0
			@options.logdir = "/var/log/rubac"
		else
			@options.logdir = "#{@options.tmp}/rubac"
		end

		# use default log
		@options.log = nil

		#
		# TODO - add additional defaults end
		#
	end

	# ensure that rsync is at least 2.5.6
	def rsync_check_version
		# rsync version must be at least 2.5.6 for --link-dest option
		rsync_version = `#{@rsync} --version`
		if $?.exitstatus != 0
			puts "Error: running #{@rsync} --version"
			exit(1)
		end
		rsync_version = rsync_version[/^rsync\s+version\W+\d+\.\d+\.\d+/]
		if rsync_version == nil
			puts "Error: could not determine rsync version"
			exit(1)
		end
		rsync_version = rsync_version[/\d+\.\d+\.\d/]
		rva = rsync_version.split(/\./)
		rvi = rva[0].to_i * 100 + rva[1].to_i * 10 + rva[2].to_i
		if rvi < 256
			puts "rsync version is too old, require at least rsync version 2.5.6"
			exit(1)
		end
	end

	# Parse options, check arguments, then process the command
	def main
 
		rsync_check_version

		if arguments_valid? && parsed_options?

			puts "Start at #{DateTime.now}\n\n" if @options.verbose

			output_options if @options.verbose # [Optional]

			process_arguments            
			process_command

			#puts "\nFinished at #{DateTime.now}" if @options.verbose
		else
			usage_command
		end
	end

	protected

	def set_command(c)
		if @options.cmd == nil
			@options.cmd="#{c}_command"
		else
			puts "Warning: Command is already set to #{@options.cmd}, ignoring #{c} command"
		end
	end

	def parsed_options?

		# Specify options
		opts = OptionParser.new 
		opts.on('-V', '--verbose', "Run verbosely")    { @options.verbose = true }  
		opts.on('-q', '--quiet',   "Run quietly")      { @options.quiet = true }

		opts.on('-g', '--global', "Apply options to the global profile") { @options.global = true }

		opts.on('--delete', "Delete any specified includes, excludes, etc") {
			@options.update_cmd = UPDATE_CMD_DEL
		}

		opts.on('-LPATH', '--logdir PATH', "Set the log directory") do |dir|
			if not File.exist?(dir)
				begin
					FileUtils.mkdir(dir)
				rescue Errno::EACCES
					puts "Error: permission denied creating log dir #{dir}"
					exit 1
				rescue
					puts "Error: creating log dir #{dir}"
					exit 1
				end
			end
			if File.stat(dir).directory?
				@options.logdir = dir
			else
				puts "Error: #{dir} is not a directory"
				exit 1
			end
		end
		
		opts.on('--log PATH', "Set the log file name") do |name|
			@options.log = name
		end

		opts.on('-cHOST', '--client HOST', "Backup Client hostname") do |host|
			host.strip!
			@options.client << host
			@options.client.uniq!
		end

		opts.on('-aHOST', '--address HOST', "Address of the specified client") do |address|
			address.strip!
			@options.address = address
		end

		opts.on('-DPATH', '--datadir PATH', "Database directory") do |dir|
			dir.strip!
			@options.datadir = dir
		end

		opts.on('-iPATH', '--include PATH', "Add include path") do |inc|
			# strip whitespace
			inc.strip!
			# remove trailing pathslash, if any
			inc = File.join(File.dirname(inc), File.basename(inc))
			if @options.include
				@options.include = @options.include + ",#{inc}"
			else
				@options.include = inc
			end
		end

		opts.on('-xPATH', '--exclude PATH', "Add exclude path") do |exc|
			exc.strip!
			if @options.exclude
				@options.exclude = @options.exclude + ",#{exc}"
			else
				@options.exclude = exc
			end
		end

		opts.on('-dPATH', '--dest PATH', "Set backup destination") do |dest|
			dest.strip!
			@options.dest = dest
		end

		opts.on('-mLIST', '--mail LIST', "Email notification list") do |email|
			@options.email = email
		end

		opts.on('--smtp SERVER', "SMTP server address") do |server|
			@options.smtp = server
		end

		opts.on('-u', '--update', "Perform an update backup ignoring incrementals") {
			@options.update = true
			set_command("run")
		}

		opts.on('-IN', '--incremental N', "Set the number of incremental backups") do |ninc|
			ninc = ninc.to_i
			if ninc < 0
				puts "Error: number of incrementals must be greater than or equal to 0"
				puts "       ignoring #{ninc}"
			else
				@options.ninc = ninc
			end
		end

		opts.on('-pNAME', '--profile NAME', "Apply opts to specified profile") do |profile|
			@options.profile = profile
		end
		# TO DO - add additional options

		opts.on('-n', '--dry-run', "Perform a trial run of the backup") do
			@options.dry_run = true
		end

		opts.on('-h', '--help',    "Print help") do   #   { output_help }
			set_command("help")
		end

		opts.on('-r', '--run', "Run the backup") do
			set_command("run")
		end

		opts.on('-sNAME', '--snapshot NAME', "Perform a snapshot backup") do |name|
			@options.snapshot = File.basename(name)
			set_command("snapshot")
		end

		opts.on('-l', '--list', "List the backup options") do
			set_command("list")
		end

		opts.on('-H', '--history [INDEX]', "Backup history") do |index|
			set_command("history")
			@options.hist_index = index.to_i if index != nil
		end

		opts.on('-v', '--version', "Print version") do
			set_command("version")
		end

		opts.parse!(@arguments) rescue return false

		process_options
		true      
	end

	# Performs post-parse processing on options
	def process_options
		@options.verbose = false if @options.quiet
		@options.dbname = @options.profile + ".xml"
	end

	def output_options
		puts "Options:\n"
      
		@options.marshal_dump.each do |name, val|        
			puts "  #{name} = #{val}"
		end
	end

	# True if required arguments were provided
	def arguments_valid?
		# TO DO - implement your real logic here
		#puts "arguments =  #{@arguments.length} \n"
		true if @arguments.length >= 1 
	end

	# Setup the arguments
	def process_arguments
		# TO DO - place in local vars, etc
		@config = Config_rubac.new
		@config.load_xml(@options.dbname, @options.datadir)

		@config.set_global_dest(@options.dest) if @options.dest

		@config.set_global_key_value("smtp", @options.smtp) if @options.smtp

		if @options.client.nitems == 0
			#@config.get_clients.each_key do |client|
			#	@options.client << client
			#end
			@options.client = @config.get_clients.keys
		end

		if @options.global
			@config.global_updates(@options.update_cmd, @options.include, @options.exclude, @options.opts)
			@config.set_global_key_value("ninc", @options.ninc) if @options.ninc
		else
			@options.client.each do |client|
				@config.client_updates(client, @options.update_cmd, @options.include, @options.exclude, @options.opts)
				@config.set_client_key_value(client, "address", @options.address) if @options.address
				@config.set_client_key_value(client, "ninc", @options.ninc) if @options.ninc
			end
		end

		@xml = @config.save_xml
	end
    
	def help_command 
		# RDoc::usage doesn't work in 1.9.x
		RDoc::usage('Synopsis', 'Usage', 'Options') #exits app
	end
    
	def usage_command
		RDoc::usage('Synopsis', 'Usage', 'Options') # gets usage from comments above
	end
 
	def run_command_prep_linkdest(host, pdest)
		ninc = @config.get_client_ninc(host)

		# setup flags for delete
		rm_flags = { :force => true, :verbose => true }
		if @options.dry_run 
			rm_flags.merge!( :noop => true )
		end

		link_dest = false
		i = []
		i = (1..ninc).to_a.reverse
		i.each do |m|
			n = m - 1
			# Example,
			#   n==4, ndest is rubac.4
			#   m==5, mdest is rubac.5

			nname = @config.get_client_incrementals(host, n)
			mname = @config.get_client_incrementals(host, m)

			puts "n=#{n} nname=#{nname} m=#{m} mname=#{mname}"

			next if nname.length == 0

			ndest = File.join(pdest, nname)
			mdest = File.join(pdest, mname)

			p ndest
			p mdest

			# Someone has deleted an incremental backup
			if not File.exist?(ndest)
				#@config.set_client_incremental(host, m, nname)
				puts "Error: incremental backup #{nname} not found"
				@config.set_client_incremental(host, m, "")
				@config.set_client_incremental(host, n, "")
				next
			end

			if m == ninc and mname.length > 0
				if File.exist?(mdest)
					FileUtils.rm_r(mdest, rm_flags)
				end
			end
			if File.exist?(ndest)
				@config.set_client_incremental(host, m, nname)
				link_dest = true
			end
		end


	end

	def run_command_fill(droot, path, log)
		bdir = Dir.new(path)
		bdir.each { |d|
			next if d == "." or d == ".."
			p = File.join(path, d)
			q = p.sub(/^#{droot}/, "")
			if File.lstat(p).directory?
				q << "/"
				log << "#{q}"
				#puts ":d:#{q}:d:"
				run_command_fill(droot, p, log)
			end
			log << "#{q}"
			#puts ":f:#{q}:f:"
		}
	end

	def run_command_rsync(host, inc, bdest, ldest)

		logf = File.join(bdest, "rubac.log.yaml")
		if File.exist?(logf)
			fill = false
			log = File.open(logf) { |yf| YAML::load(yf) }
			puts "Log found: loaded #{logf} with #{log.nitems}"
		else
			fill = true
			log = Array.new
		end

		cmd =  %Q(rsync #{@sshopts} #{@useropts})
		cmd << %Q( --link-dest=#{ldest}) if ldest
		# write the excludes to a file and use --exclude-from 
		if @excludes.length > 0
			excl = File.join(@options.tmp, File.basename(bdest) + ".excl")
			exclf = File.open( excl, "w" )
			@excludes.split(",").each do |x|
				exclf.puts( x )
			end
			exclf.close
			cmd << %Q( --exclude-from="#{excl}") if @excludes.length > 0
		end
		cmd << %Q( #{inc} #{bdest})
		puts %Q(#{cmd})
		#Open3.popen3(cmd) { |stdin,stdout,stderr|
		#	line = stdout.read
		#	line.chop!
		#	puts "DD:#{line}:DD"
		#	# if deleting, remove the file from 'log', if it exists
		#	# ^deleting home/rico/.thumbnails/normal/6bf9e300a41296740a5fdd89b98e1d93.png
		#	if line[/^#{inc}.*/]
		#		puts "ii#{line}ii"
		#		log << line
		#	elsif line[/.*\sis uptodate$/]
		#		line.sub!(/\s is uptodate/, "")
		#		line = "/" + line
		#		puts "uu#{line}uu"
		#	elsif line[/^\s*deleting\s+/]
		#		line.sub!(/^\s*deleting\s+/, "/")
		#		puts "xx#{line}xx"
		#		log.delete(line)
		#	else
		#		puts "::#{line}::"
		#	end
		#
		#	line = stderr.read
		#	line.chop!
		#	puts "ERROR: #{line}" if line.length > 0
		#
		#}
		p = IO.popen(cmd)
		while (line = p.gets)
			line.chop!
			# if deleting, remove the file from 'log', if it exists
			# ^deleting home/rico/.thumbnails/normal/6bf9e300a41296740a5fdd89b98e1d93.png
			if line[/^#{inc}.*/]
				puts "ii#{line}ii"
				log << line
			elsif line[/\sis uptodate$/]
				line.sub!(/\sis uptodate$/, "")
				line = "/" + line
				puts "uu:#{line}:uu"
				log << line
			elsif line[/^\s*deleting\s+/]
				line.sub!(/^\s*deleting\s+/, "/")
				puts "xx#{line}xx"
				log.delete(line)
			else
				puts "::#{line}::"
			end
		end
		
		## TODO get status of command??
		status=$?
		p status
		#out = %x{#{cmd}}
		#status = $?.exitstatus
		#puts out
		if status and status != 0
			puts "Error: running command %Q(#{cmd})"
			exit(status)
		end

		bdir = File.join(bdest, inc)
		run_command_fill(bdest, bdir, log) if fill

		# remove duplicates
		log.uniq!

		puts "Backup log length=#{log.nitems} to #{logf}"
		File.open( logf, "w" ) do |out|
			YAML.dump( log, out )
		end

	#	log.each do |entry|
	#		puts entry
	#	end
	end

	def get_backup_dirname
		t = Time.now
		t.strftime("%Y-%m-%d_%H-%M-%S")
		"rubac." + t.strftime("%Y-%m-%d_%H-%M-%S")
	end

	# backup to bdir with hardlink to ldir, if it exists
	def run_command
		host = @client

		if @dest.length == 0
			puts "Error: backup destination not set"
			exit(1)
		end

		if @options.snapshot
			bdir = "rubac.#{@options.snapshot}"
			ldir = @config.get_client_incrementals(host, 0)
		elsif @options.update
			bdir = @config.get_client_incrementals(host, 0)
			bdir = get_backup_dirname if bdir.length == 0
			ldir = "__none__"
		else
			bdir = get_backup_dirname
			ldir = @config.get_client_incrementals(host, 0)
		end

		ldir = "__none__" if ldir.length == 0

		pdest = File.join(@dest, @options.profile, host)
		FileUtils.mkdir_p(pdest)

		# if flock(LOCK_EX|LOCK_NB) == false puts "cannot get exclusive lock"
		# g=File.new("/tmp/junkol", File::CREAT|File::RDONLY, 0600)
		# g.flock(File::LOCK_EX|File::LOCK_NB)
		#
		rlock = File.join(pdest, "rubac.runlock")
		runlock = File.new(rlock, File::CREAT|File::RDONLY, 0644)
		if runlock.flock(File::LOCK_EX|File::LOCK_NB) == false
			puts "Error: cannot lock file #{rlock}"
			runlock.close
			return
		end

		bdest = File.join(pdest, bdir)
		ldest = File.join(pdest, ldir)

		if @options.snapshot
			if not File.exist?(ldest)
				puts "Error: run one backup before doing a snapshot"
				exit (1)
			end
		elsif @options.update
			puts "Running full backup on #{bdest}"
			ldest = nil
		else
			# move out incrementals
			run_command_prep_linkdest(host, pdest) if ldir != "__none__"
			# if the link destination doesn't exist, set it to nil
			ldest = nil if not File.exist?(ldest)
		end

		# assert that bdest doesn't exist here?
		FileUtils.mkdir_p(bdest)

		# copy previous backup log to bdest, but only if it doesn't
		# already exist
		#blogf = File.join(bdest, "rubac.log.yaml")
		#if not File.exist?(blogf) and ldest
		#	llogf = File.join(ldest, "rubac.log.yaml")
		#	if File.exist?(llogf)
		#		FileUtils.copy(llogf, blogf, :verbose => true)
		#	end
		#end

		# log history files by include
		# include => "file, file, file, ..."
		inc = @includes.split(",")
		inc.each do |i|
			# strip off any trailing path slashes
			ifp = File.join(File.dirname(i), File.basename(i))
			run_command_rsync(host, ifp, bdest, ldest)
			@config.set_client_incremental(host, 0, bdir)
		end

		@config.save_xml

		runlock.flock(File::LOCK_UN)
		File.delete(rlock)
	end

	#
	# Do a backup snapshot (not a real filesystem snapshot) by
	# backing up to the snapshot and linking to rubac.0
	#
	def snapshot_command
		puts "##### Snapshot=#{@options.snapshot} #####"
		run_command
	end

	def list_command_client_key(client, key, delim=",")
		if delim
			inc = @config.get_client_key_list(client, key, delim)
		else
			inc = @config.get_client_key_value(client, key)
			delim = " "
		end

		return if inc.length == 0

		inc = inc.split("#{delim}")
		printf "%10s=", key

		if inc.nitems > 1
		inc.each do |i|
			printf "\n\t%-12s", i
		end
		else
			printf "%s", inc[0]
		end
		puts ""
	end

	def list_command_client(client)
		puts "##### #{client} #####"
		list_command_client_key(client, 'includes')
		list_command_client_key(client, 'excludes')
		list_command_client_key(client, 'opts', " ")
		list_command_client_key(client, 'ninc', nil)
	end

	def list_command_global_settings
		return if @global_settings
		@global_settings = true

		puts "##### Global settings #####"
		printf "%10s=%s\n", "profile", @options.profile
		if @dest.length == 0
			puts %Q(   *** Warning: backup destination not set)
		else
			printf %Q(%10s=%s\n), "dest", @dest
		end
		printf %Q(%10s=%s\n), "ssh opts", @sshopts
		printf %Q(\n)
		@global_settings = true
	end

	def list_command

		if @options.verbose
			puts "##### Configuration #####"
			puts "#{@xml}\n"
		end

		list_command_global_settings

		list_command_client(@client)

		#puts "##### Email test"
		#email = Email.new
		#email.server = @config.get_global_key_value("smtp")
		#email.to("steeve.mccauley@gmail.com", "Steeve McCauley")
		#email.to("steeve@oneguycoding.com", "One Guy Coding")
		#email.from("rubac@linguini.home", "Rubac Backup User")
		#subject = "Rubac Test"
		#body = "This is a test email\nThis is the second line\nThis is the last line\n"
		#email.send(subject, body, @config.get_global_key_value("smtp", nil))

		#$o.debug("this is a debug message")
		#$o.info("this is an info message")
		#$o.warn("this is a warning message")
		#$o.err("this is a warning message")
		#$o.die("this is a die message")
	end

	def history_command_display(cli, hist)
		return if hist.nitems == 0

		if @options.hist_index != nil
			puts "#{cli}:#{@options.hist_index}: #{hist[0]}"
			logf = File.join(@dest, @options.profile, @client, hist[0], "rubac.log.yaml")
			if File.exist?(logf)
				log = File.open(logf) { |yf| YAML::load(yf) }
				log.each do |line|
					puts line
				end
			else
				puts "Error: opening #{logf}"
			end
			return
		end

		hist.each_index do |i|
			puts "#{cli}:#{i}: #{hist[i]}"
		end
	end

	def history_command_get_history(cli)
		entries = []
		ninc = @config.get_client_ninc(cli)
		return entries if ninc == nil or ninc == 0

		ninc.times do |n|
			next if @options.hist_index != nil and @options.hist_index != n
			name = @config.get_client_incrementals(cli, n)
			break if name.length == 0
			entries << name
		end
		entries
	end

	def history_command
		hist = []
		puts "##### history command #####"
		# look in /bdest/profile/client/rubac.date,.../rubac.log.yaml
		hist = history_command_get_history(@client)
		history_command_display(@client, hist)
	end

	def version_command
		ver = @config.version
		puts "#{File.basename(__FILE__)} " + ver
	end
    
	def process_command_client(client)
		@client = client
		@includes = @config.get_client_includes(client)
		@excludes = @config.get_client_excludes(client)
		@useropts = @config.get_client_opts(client)
		@address = @config.get_client_address(client)

		eval @options.cmd
	end

	def process_command
		@dest = @config.get_global_dest

		puts "Warning: backup destination not set" if not File.exist?(@dest)

		@sshopts  << " --dry-run" if @options.dry_run

		version_command

		case @options.cmd
		when "version_command"
			# already done above
		when "help_command", "usage_command"
			eval @options.cmd
		when "run_command", "snapshot_command", "list_command", "history_command"
			@options.client.each do |client|
				puts ">>>>> Running #{@options.cmd} for #{client}"
				process_command_client(client)
				puts "<<<<< Done running #{@options.cmd} for #{client}"
			end
		else
			puts "huh? #{Config::CONFIG['host_os']}"
		end

	end

	#def process_standard_input
	#	input = @stdin.read      
		# TO DO - process input

		# [Optional]
		# @stdin.each do |line| 
		#  # TO DO - process each line
		# end
	#end
end

$o = Msg.new("console,syslog,fart")

rubac = Rubac.new(ARGV, STDIN)
rubac.main

